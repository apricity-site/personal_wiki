<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第三章 客户端开发向导 | APRICITY</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="个人知识库">
    
    <link rel="preload" href="/personal_wiki/assets/css/0.styles.65ccb39f.css" as="style"><link rel="preload" href="/personal_wiki/assets/js/app.d60e7411.js" as="script"><link rel="preload" href="/personal_wiki/assets/js/2.487a0e24.js" as="script"><link rel="preload" href="/personal_wiki/assets/js/13.ad4f0c53.js" as="script"><link rel="prefetch" href="/personal_wiki/assets/js/10.83cc57ab.js"><link rel="prefetch" href="/personal_wiki/assets/js/11.342c6dde.js"><link rel="prefetch" href="/personal_wiki/assets/js/12.fb7b3bce.js"><link rel="prefetch" href="/personal_wiki/assets/js/14.1e7cab5b.js"><link rel="prefetch" href="/personal_wiki/assets/js/15.cbdbc27a.js"><link rel="prefetch" href="/personal_wiki/assets/js/16.1ba1c252.js"><link rel="prefetch" href="/personal_wiki/assets/js/17.88091353.js"><link rel="prefetch" href="/personal_wiki/assets/js/18.3285ccaa.js"><link rel="prefetch" href="/personal_wiki/assets/js/19.9da75aa9.js"><link rel="prefetch" href="/personal_wiki/assets/js/20.f2217f22.js"><link rel="prefetch" href="/personal_wiki/assets/js/3.131c70a8.js"><link rel="prefetch" href="/personal_wiki/assets/js/4.b5c5d85a.js"><link rel="prefetch" href="/personal_wiki/assets/js/5.aedbb9bc.js"><link rel="prefetch" href="/personal_wiki/assets/js/6.7dd3e1f3.js"><link rel="prefetch" href="/personal_wiki/assets/js/7.c597da36.js"><link rel="prefetch" href="/personal_wiki/assets/js/8.518a8b15.js"><link rel="prefetch" href="/personal_wiki/assets/js/9.8d4d5d94.js">
    <link rel="stylesheet" href="/personal_wiki/assets/css/0.styles.65ccb39f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/personal_wiki/" class="home-link router-link-active"><!----> <span class="site-name">APRICITY</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="读书笔记" class="mobile-dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/personal_wiki/book/rabbitmq-in-action-guide/" class="nav-link router-link-active">
  rabbitmq实战指南
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="课程笔记" class="dropdown-title"><span class="title">课程笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="课程笔记" class="mobile-dropdown-title"><span class="title">课程笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/personal_wiki/course/ci-cd/" class="nav-link">
  CI/CD
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具" class="mobile-dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/personal_wiki/tools/vagrant/get_startting.html" class="nav-link">
  vagrant
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="读书笔记" class="mobile-dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/personal_wiki/book/rabbitmq-in-action-guide/" class="nav-link router-link-active">
  rabbitmq实战指南
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="课程笔记" class="dropdown-title"><span class="title">课程笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="课程笔记" class="mobile-dropdown-title"><span class="title">课程笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/personal_wiki/course/ci-cd/" class="nav-link">
  CI/CD
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具" class="mobile-dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/personal_wiki/tools/vagrant/get_startting.html" class="nav-link">
  vagrant
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/personal_wiki/book/rabbitmq-in-action-guide/" aria-current="page" class="sidebar-link">rabbitmq入门</a></li><li><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html" class="active sidebar-link">第三章 客户端开发向导</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html#连接rabbitmq" class="sidebar-link">连接RabbitMQ</a></li><li class="sidebar-sub-header"><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html#使用交换器和队列" class="sidebar-link">使用交换器和队列</a></li><li class="sidebar-sub-header"><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html#发送消息" class="sidebar-link">发送消息</a></li><li class="sidebar-sub-header"><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html#消费消息" class="sidebar-link">消费消息</a></li><li class="sidebar-sub-header"><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html#消费端得确认与拒绝" class="sidebar-link">消费端得确认与拒绝</a></li><li class="sidebar-sub-header"><a href="/personal_wiki/book/rabbitmq-in-action-guide/03_客户端开发向导.html#关闭连接" class="sidebar-link">关闭连接</a></li></ul></li><li><a href="/personal_wiki/book/rabbitmq-in-action-guide/04_RabbitMQ进阶.html" class="sidebar-link">第四章 RabbitMQ进阶</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第三章-客户端开发向导"><a href="#第三章-客户端开发向导" class="header-anchor">#</a> 第三章 客户端开发向导</h1> <h2 id="连接rabbitmq"><a href="#连接rabbitmq" class="header-anchor">#</a> 连接RabbitMQ</h2> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">// 获取Connection</span>
	<span class="token keyword">public</span> <span class="token class-name">Connection</span> <span class="token function">geConnection</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span>
                                   <span class="token class-name">String</span> password<span class="token punctuation">,</span>
                                   <span class="token class-name">String</span> virtualHost<span class="token punctuation">,</span>
                                   <span class="token class-name">String</span> host<span class="token punctuation">,</span>
                                   <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>
            factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
            factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span>virtualHost<span class="token punctuation">)</span><span class="token punctuation">;</span>
            factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>
            factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CreateConnFailedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Connection</span> <span class="token function">geConnection</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            factory<span class="token punctuation">.</span><span class="token function">setUri</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">URISyntaxException</span> <span class="token operator">|</span>
                <span class="token class-name">NoSuchAlgorithmException</span> <span class="token operator">|</span>
                <span class="token class-name">KeyManagementException</span> <span class="token operator">|</span>
                <span class="token class-name">IOException</span> <span class="token operator">|</span>
                <span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CreateConnFailedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 获取Channel</span>
    <span class="token keyword">public</span> <span class="token class-name">Channel</span> <span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">geConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <ol><li><p>channel非线程安全</p> <p><code>Connection</code>可以用来创建多个<code>Channel</code>实例，但是<code>Channel</code>实例不能在线程间共享，应用程序应该为每一个线程开辟一个Channel。某些情况下<code>Channel</code>的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响发送方确认（<code>publisher confirm</code>）机制的运行（详细可以参考4.8节），所以多线程间共享<code>Channel</code>实例是非线程安全的。</p></li> <li><p>channel的<code>isOpen</code>方法</p> <p>通常情况下，在调用<code>createXXX</code>或者<code>newXXX</code>方法之后，我们可以简单地认为<code>Connection</code>或者<code>Channel</code>已经成功地处于开启状态，而并不会在代码中使用<code>isOpen</code>这个检测方法。如果在使用Channel的时候其已经处于关闭状态，那么程序会抛出一个<code>com.rabbitmq.client.ShutdownSignalException</code>，我们只需捕获这个异常即可。当然同时也要试着捕获<code>IOException</code>或者<code>SocketException</code>，以防Connection意外关闭。</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">createChannel</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span> <span class="token class-name">ShutdownSignalException</span> <span class="token operator">|</span> <span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div></li></ol> <h2 id="使用交换器和队列"><a href="#使用交换器和队列" class="header-anchor">#</a> 使用交换器和队列</h2> <p>交换器和队列是AMQP中high-level层面的构建模块，应用程序需确保在使用它们的时候就已经存在了，在使用之前需要先声明（declare）它们。</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">directBind</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> exchangeName<span class="token punctuation">,</span> <span class="token class-name">String</span> routeingKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">createChannel</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">&quot;direct&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> queueName <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> exchangeName<span class="token punctuation">,</span> routeingKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> queueName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>上面创建了一个持久化的、非自动删除的、绑定类型为direct的交换器，同时也创建了一个非持久化的、排他的、自动删除的队列（此队列的名称由RabbitMQ自动生成）。这里的交换器和队列也都没有设置特殊的参数。
上面的代码也展示了如何使用路由键将队列和交换器绑定起来。上面声明的队列具备如下特性：只对当前应用中同一个Connection层面可用，同一个Connection的不同Channel可共用，并且也会在应用连接断开时自动删除。</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">// 这里的队列被声明为持久化的、非排他的、非自动删除的，而且也被分配另一个确定的已知的名称（由客户端分配而非RabbitMQ自动生成）。</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">directBind</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span>
                           <span class="token class-name">String</span> exchangeName<span class="token punctuation">,</span>
                           <span class="token class-name">String</span> queueName<span class="token punctuation">,</span>
                           <span class="token class-name">String</span> routeingKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">createChannel</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">&quot;direct&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> exchangeName<span class="token punctuation">,</span> routeingKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>生产者和消费者都可以声明一个交换器或者队列。如果尝试声明一个已经存在的交换器或者队列，只要声明的参数完全匹配现存的交换器或者队列，RabbitMQ就可以什么都不做，并成功返回。如果声明的参数不匹配则会抛出异常。</p> <h3 id="创建方法详解"><a href="#创建方法详解" class="header-anchor">#</a> 创建方法详解</h3> <h4 id="exchangedeclare"><a href="#exchangedeclare" class="header-anchor">#</a> <code>exchangeDeclare</code></h4> <p>重要参数解释：</p> <ul><li><code>exchange</code>：交换器的名称。</li> <li><code>type</code>：交换器的类型，常见的如<code>fanout</code>、<code>direct</code>、<code>topic</code>，详情参见2.1.4节。</li> <li><code>durable</code>：设置是否持久化。<code>durable</code>设置为true表示持久化，反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li> <li><code>autoDelete</code>：设置是否自动删除。<code>autoDelete</code>设置为true则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个</li> <li>交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为：“当与此交换器连接的客户端都断开时，RabbitMQ会自动删除本交换器”。
<code>internal</code>：设置是否是内置的。如果设置为true，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li></ul> <h4 id="queuedeclare"><a href="#queuedeclare" class="header-anchor">#</a> <code>queueDeclare</code></h4> <ul><li><code>queue</code>：队列的名称。</li> <li><code>durable</code>：设置是否持久化。为true则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li> <li><code>exclusive</code>：设置是否排他。为true则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点：排他队列是基于连接（Connection）可见的，同一个连接的不同信道（Channel）是可以同时访问同一连接创建的排他队列；“首次”是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li> <li><code>autoDelete</code>：设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li></ul> <h4 id="queuebind"><a href="#queuebind" class="header-anchor">#</a> <code>queueBind</code></h4> <p>将队列和交换器绑定的方法</p> <ul><li><code>queue</code>：队列名称；</li> <li><code>exchange</code>：交换器的名称；</li> <li><code>routingKey</code>：用来绑定队列和交换器的路由键；</li> <li><code>argument</code>：定义绑定的一些参数。</li></ul> <h4 id="exchangebind"><a href="#exchangebind" class="header-anchor">#</a> <code>exchangeBind</code></h4> <p>我们不仅可以将交换器与队列绑定，也可以将交换器与交换器绑定</p> <h3 id="何时创建"><a href="#何时创建" class="header-anchor">#</a> 何时创建</h3> <p>RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如果要衡量RabbitMQ当前的QPS只需看队列的即可。在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。</p> <p>按照RabbitMQ官方建议，生产者和消费者都应该尝试创建（这里指声明操作）队列。这是一个很好的建议，但不适用于所有的情况。如果业务本身在架构设计之初已经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好（比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发），这样业务程序也可以免去声明的过程，直接使用即可。
预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失；或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合**<code>mandatory</code>**参数或者备份交换器（详细可参考4.1节）来提高程序的健壮性。（当mandatory标志位设置为true时，如果<code>exchange</code>根据自身类型和消息<code>routingKey</code>无法找到一个合适的queue存储消息，那么broker会调用<code>basic.return</code>方法将消息返还给生产者;当<code>mandatory</code>设置为<code>fals</code>e时，出现上述情况broker会直接将消息丢弃;）</p> <p>与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。
如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。
至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p> <h2 id="发送消息"><a href="#发送消息" class="header-anchor">#</a> 发送消息</h2> <div class="language-java extra-class"><pre class="language-java"><code>	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">,</span>
                            <span class="token class-name">String</span> exchange<span class="token punctuation">,</span>
                            <span class="token class-name">String</span> routingKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">createChannel</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>参数：</p> <ul><li><code>exchange</code>：交换器的名称，指明消息需要发送到哪个交换器中。如果设置为空字符串，则消息会被发送到RabbitMQ默认的交换器中。</li> <li><code>routingKey</code>：路由键，交换器根据路由键将消息存储到相应的队列之中。</li> <li><code>props</code>：消息的基本属性集，其包含14个属性成员，分别有<code>contentType、contentEncoding、headers(Map&amp;lt;String,Object&amp;gt;)</code>、<code>deliveryMode、priority、correlationId、replyTo、expiration、messageId、timestamp、type、userId、appId、clusterId</code>。其中常用的几种都在上面的示例中进行了演示。</li> <li><code>byte[] body</code>：消息体（payload），真正需要发送的消息。</li> <li><code>mandatory</code>和<code>immediate</code>的详细内容请参考4.1节。</li></ul> <h2 id="消费消息"><a href="#消费消息" class="header-anchor">#</a> 消费消息</h2> <h3 id="推模式"><a href="#推模式" class="header-anchor">#</a> 推模式</h3> <p><code>RabbitMQ</code>的消费模式分两种：<strong>推(Push)模式和拉(Pull)模式</strong>。推模式采用<code>Basic.Consume</code>进行消费，而拉模式则是调用<code>Basic.Get</code>进行消费</p> <p>接收消息一般通过实现Consumer接口或者继承<code>DefaultConsumer</code>类来实现。当调用与<code>Consumer</code>相关的API方法时，不同的订阅采用不同的消费者标签<code>（consumerTag）</code>来区分彼此，在同一个Channel中的消费者也需要通过唯一的消费者标签以作区分</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pushConsume</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> queueName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> autoAck <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> consumerTag <span class="token operator">=</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">createChannel</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> autoAck<span class="token punctuation">,</span> consumerTag<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span><span class="token class-name">String</span> consumerTag<span class="token punctuation">,</span>
                                       <span class="token class-name">Envelope</span> envelope<span class="token punctuation">,</span>
                                       <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties<span class="token punctuation">,</span>
                                       <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> routingKey <span class="token operator">=</span> envelope<span class="token punctuation">.</span><span class="token function">getRoutingKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">String</span> contentType <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getContentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">long</span> deliveryTag <span class="token operator">=</span> envelope<span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>上面代码中显式地设置<code>autoAck</code>为<code>false</code>，然后在接收到消息之后进行显式<code>ack</code>操作（<code>channel.basicAck</code>），对于消费者来说这个设置是非常必要的，可以防止消息不必要地丢失。</strong></p> <p>参数：</p> <ul><li><code>queue</code>：队列的名称；</li> <li><code>autoAck</code>：设置是否自动确认。建议设成false，即不自动确认；</li> <li><code>consumerTag</code>：消费者标签，用来区分多个消费者；</li> <li><code>noLocal</code>：设置为true则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者；</li> <li><code>exclusive</code>：设置是否排他；</li> <li><code>arguments</code>：设置消费者的其他参数；</li> <li><code>callback</code>：设置消费者的回调函数。用来处理RabbitMQ推送过来的消息，比如<code>DefaultConsumer</code>，使用时需要客户端重写（override）其中的方法。</li></ul> <p>重写客户端方法：</p> <ul><li><p><code>handleShutdownSignal</code>方法，当Channel或者Connection关闭的时候会调用。</p></li> <li><p><code>handleConsumeOk</code>方法会在其他方法之前调用，返回消费者标签。</p></li> <li><p><code>handleCancelOk</code>和<code>handleCancel</code>方法，这样消费端可以在显式地或者隐式地取消订阅的时候调用。也可以通过<code>channel.basicCancel</code>方法来显式地取消一个消费者的订阅</p></li> <li><p><code>channel.basicCancel</code>这行代码会首先触发<code>handleConsumerOk</code>方法，之后触发<code>handleDelivery</code>方法，最后才触发<code>handleCancelOk</code>方法。</p></li></ul> <p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些callback会被分配到与Channel不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法，比如<code>channel.queueDeclare、channel.basicCancel</code>等。</p> <p>每个Channel都拥有自己独立的线程。最常用的做法是一个Channel对应一个消费者，也就是意味着消费者彼此之间没有任何关联。当然也可以在一个Channel中维持多个消费者，但是要注意一个问题，如果Channel中的一个消费者一直在运行，那么其他消费者的callback会被<strong>耽搁</strong>。</p> <h3 id="拉模式"><a href="#拉模式" class="header-anchor">#</a> 拉模式</h3> <p>通过<code>channel.basicGet</code>方法可以单条地获取消息，其返回值是<code>GetRespone</code>。</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pullConsumeDemo</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> queueName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">createChannel</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">GetResponse</span> getResponse <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">basicGet</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h3> <ul><li>Basic.Consume将信道（Channel）置为接收模式，直到取消队列的订阅为止。</li> <li>在接收模式期间，RabbitMQ会不断地推送消息给消费者</li> <li>推送消息的个数会受到Basic.Qos的限制。如果只想从队列获得单条消息而不是持续订阅，建议还是使用Basic.Get进行消费。</li> <li>不能将Basic.Get放在一个循环里来代替Basic.Consume，这样做会严重影响RabbitMQ的性能。如果要实现高吞吐量，消费者理应使用Basic.Consume方法。</li></ul> <h2 id="消费端得确认与拒绝"><a href="#消费端得确认与拒绝" class="header-anchor">#</a> 消费端得确认与拒绝</h2> <p>当autoAck等于false时，RabbitMQ会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。当autoAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</p> <p>采用消息确认机制后，只要设置autoAck参数为false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用Basic.Ack命令为止。</p> <p>当autoAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。如果RabbitMQ一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p> <p>RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开，这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</p> <p>RabbtiMQ的Web管理平台（详细参考第5.3节）上可以看到当前队列中的“Ready”状态和“Unacknowledged”状态的消息数，分别对应上文中的等待投递给消费者的消息数和已经投递给消费者但是未收到确认信号的消息数，</p> <h3 id="basicreject"><a href="#basicreject" class="header-anchor">#</a> <code>basicReject</code></h3> <p>RabbitMQ在2.0.0版本开始引入了Basic.Reject这个命令，消费者客户端可以调用与其对应的channel.basicReject方法来告诉RabbitMQ拒绝这个消息。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">basicReject</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> requeue<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
</code></pre></div><p>如果requeue参数设置为true，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者；如果requeue参数设置为false，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</p> <h3 id="basicnack"><a href="#basicnack" class="header-anchor">#</a> <code>basicNack</code></h3> <p>Basic.Reject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用Basic.Nack这个命令。消费者客户端可以调用channel.basicNack方法来实现，方法定义如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">void</span> <span class="token function">basicNack</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">,</span> <span class="token keyword">boolean</span> requeue<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
</code></pre></div><p>multiple参数设置为false则表示拒绝编号为deliveryTag的这一条消息，这时候basicNack和basicReject方法一样；multiple参数设置为true则表示拒绝deliveryTag编号之前所有未被当前消费者确认的消息。</p> <h2 id="关闭连接"><a href="#关闭连接" class="header-anchor">#</a> 关闭连接</h2> <div class="language-java extra-class"><pre class="language-java"><code>channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在Connection关闭的时候，Channel也会自动关闭。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/personal_wiki/book/rabbitmq-in-action-guide/" class="prev router-link-active">
        rabbitmq入门
      </a></span> <span class="next"><a href="/personal_wiki/book/rabbitmq-in-action-guide/04_RabbitMQ进阶.html">
        第四章 RabbitMQ进阶
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/personal_wiki/assets/js/app.d60e7411.js" defer></script><script src="/personal_wiki/assets/js/2.487a0e24.js" defer></script><script src="/personal_wiki/assets/js/13.ad4f0c53.js" defer></script>
  </body>
</html>
